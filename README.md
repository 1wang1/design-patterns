design-patterns
[toc]
# 设计模式的六大原则

1. 开闭原则（Open Close Principle）

    开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

1. 里氏代换原则（Liskov Substitution Principle）

	里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

1. 依赖倒转原则（Dependence Inversion Principle）

	 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

1. 接口隔离原则（Interface Segregation Principle）

	 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

1. 迪米特法则，又称最少知道原则（Demeter Principle）

	 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

1. 合成复用原则（Composite Reuse Principle）

	 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。
# 创建型模式

创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

**包含模式**

- 简单工厂模式（Simple Factory）

  重要程度：4 （5为满分）

- 工厂方法模式（Factory Method）

  重要程度：5

- 抽象工厂模式（Abstract Factory）

  重要程度：5

- 建造者模式（Builder）

  重要程度：2

- 原型模式（Prototype）

  重要程度：3

- 单例模式（Singleton）

  重要程度：4

## 简单工厂模式4
### 简单工厂模式的主要优缺点
1. 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，
2. 但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码（违反开闭原则），而且产品较多时，工厂方法代码将会非常复杂。
### 简单工厂模式的应用场景
1. 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。
## 工厂方法模式5
### 工厂模式的主要优缺点：
1. 工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；
2. 其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。

### 工厂模式的主要应用场景
1. 工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。

## 抽象工厂模式5
### 抽象工厂模式的主要优缺点：
1. 抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；
2. 主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。

### 抽象工厂模式的主要应用场景
1. 抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

## 单例模式4

### 单例模式的主要优缺点：

1. 单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；
2. 其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。

### 单例模式的主要应用场景

1. 系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。（一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现。）

# 结构型模式

结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。

结构型模式可以分为**类结构型模式**和**对象结构型模式**：

- 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。

- 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 

  

根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。

**包含模式**

- 适配器模式(Adapter)

  重要程度：4

- 桥接模式(Bridge)

  重要程度：3

- 组合模式(Composite)

  重要程度：4

- 装饰模式(Decorator)

  重要程度：3

- 外观模式(Facade)

  重要程度：5

- 享元模式(Flyweight)

  重要程度：1

- 代理模式(Proxy)

  重要程度：4

## 适配器模式4

### 适配器模式的主要优缺点

1. 适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；
2. 类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。

### 适配器模式的主要应用场景

1. 适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作

### 实例：

Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。

## 桥接模式3

## 装饰模式3

## 外观模式5

## 享元模式1

## 代理模式4



# FAQ

## 1. 关于为什么使用工厂模式，而不是直接new
目前我的理解主要由两点：
1. 降低代码复杂度：工厂模式下，**不仅仅只有实例化功能，**可以对new的对象进行一些其他操作，比如工厂类创建的圆形，可以添加一些额外的设置，圆的名称，圆的颜色等（这里只是简单举例，有些可能涉及复杂的操作，比如计算设置圆的周长，面积）：**组合优先于继承相比于继承，我们更优先使用组合**——对于组合的好处，可以参考“状态模式(State Pattern)”，一个类可能需要非常多的组件，工厂模式可以降低使用者的代码复杂度和理解难度
2. 根据DP（迪米特法则）其实调用者并不知道有一个Circle类的存在，他只需要知道这个IShape接口可以计算圆面积，而不需要知道；圆这个类到底是什么类名——他只知道给定一个”circle"字符串的参数,IShape接口可以自动计算圆的面积就可以了！

## 2. 抽象工厂模式和工厂模式的区别
1. 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。

